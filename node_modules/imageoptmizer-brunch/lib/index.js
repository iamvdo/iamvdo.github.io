// Generated by CoffeeScript 1.3.3
(function() {
  var ImageOptimzer, exec, exists, fs, path, smushit, spawn, sysPath, _ref;

  _ref = require('child_process'), spawn = _ref.spawn, exec = _ref.exec;

  fs = require("fs");

  path = require("path");

  sysPath = require('path');

  smushit = require('node-smushit');

  exists = fs.exists || path.exists;

  module.exports = ImageOptimzer = (function() {

    ImageOptimzer.prototype.brunchPlugin = true;

    ImageOptimzer.prototype.png = [".png", ".bmp", ".gif", ".pnm", ".tiff"];

    ImageOptimzer.prototype.jpegs = [".jpg", "jpeg"];

    ImageOptimzer.prototype._PNGBin = 'optipng';

    ImageOptimzer.prototype._JPGBin = 'jpegtran';

    ImageOptimzer.prototype.imagePath = 'images';

    function ImageOptimzer(config) {
      var _ref1, _ref2, _ref3, _ref4,
        _this = this;
      this.config = config;
      if (this.config.imageoptimizer != null) {
        console.warn('Configuration for ImageOptimzer has been moved from config.imageoptimizer to config.plugins.imageoptimizer. Please adjust your Brunch config file accordingly.');
      }
      if ((_ref1 = this.config.plugins) != null ? (_ref2 = _ref1.imageoptimizer) != null ? _ref2.path : void 0 : void 0) {
        this.imagePath = this.config.plugins.imageoptimizer.path;
      }
      this.imagePath = sysPath.join(this.config.paths["public"], this.imagePath);
      if (!((_ref3 = this.config.plugins) != null ? (_ref4 = _ref3.imageoptimizer) != null ? _ref4.smushit : void 0 : void 0)) {
        exec("" + this._PNGBin + " --version", function(error, stdout, stderr) {
          if (error) {
            return console.error("You need to have optipng and jpegtran on your system");
          }
        });
      }
      null;
    }

    ImageOptimzer.prototype.onCompile = function(generatedFiles) {
      var files, filesjpeg, _ref1, _ref2,
        _this = this;
      if (!this.config.optimize) {
        return;
      }
      if (!fs.existsSync(this.imagePath)) {
        return;
      }
      if ((_ref1 = this.config.plugins) != null ? (_ref2 = _ref1.imageoptimizer) != null ? _ref2.smushit : void 0 : void 0) {
        return smushit.smushit(this.imagePath, {
          recursive: true
        });
      } else {
        files = this.readDirSync(this.imagePath);
        if (files.png.length) {
          this.optimizePNG(files.png, function(error, result) {
            return console.log("Compressed " + files.png.length + " png files via " + _this._PNGBin);
          });
        }
        if (files.jpeg.length) {
          filesjpeg = files.jpeg.slice(0);
          return this.optimizeJPG(files.jpeg, function(error, result) {
            return console.log("Compressed " + filesjpeg.length + " jpeg files via " + _this._JPGBin);
          });
        }
      }
    };

    ImageOptimzer.prototype.calculateSizeFromImages = function(files) {
      var size;
      size = 0;
      files.forEach(function(file) {
        return size += fs.statSync(file).size;
      });
      return size;
    };

    ImageOptimzer.prototype.readDirSync = function(baseDir) {
      var fileList, readdirSyncRecursive,
        _this = this;
      baseDir = baseDir.replace(/\/$/, "");
      fileList = {
        png: [],
        jpeg: []
      };
      readdirSyncRecursive = function(baseDir) {
        var curFiles, files, isDir, nextDirs, prependBaseDir;
        files = [];
        isDir = function(fname) {
          return fs.statSync(sysPath.join(baseDir, fname)).isDirectory();
        };
        prependBaseDir = function(fname) {
          return sysPath.join(baseDir, fname);
        };
        curFiles = fs.readdirSync(baseDir);
        nextDirs = curFiles.filter(isDir);
        curFiles = curFiles.map(prependBaseDir);
        files = files.concat(curFiles);
        while (nextDirs.length) {
          files = files.concat(readdirSyncRecursive(sysPath.join(baseDir, nextDirs.shift())));
        }
        return files;
      };
      readdirSyncRecursive(baseDir).forEach(function(filepath) {
        if (!!~_this.png.indexOf(path.extname(filepath).toLowerCase())) {
          fileList.png.push(filepath);
        }
        if (!!~_this.jpegs.indexOf(path.extname(filepath).toLowerCase())) {
          return fileList.jpeg.push(filepath);
        }
      });
      return fileList;
    };

    ImageOptimzer.prototype.optimizeJPG = function(files, callback) {
      var clean, error, options, result, run, tmpfile,
        _this = this;
      error = null;
      result = '';
      tmpfile = 'jpgtmp.jpg';
      options = ['-copy', 'none', '-optimize', '-outfile', 'jpgtmp.jpg'];
      (run = function(file) {
        var args, jpegtran, wStream;
        if (!file) {
          return clean();
        }
        args = options.concat(file);
        wStream = null;
        jpegtran = spawn(_this._JPGBin, args);
        return jpegtran.on('exit', function(code) {
          if (code) {
            return;
          }
          fs.writeFileSync(file, fs.readFileSync(tmpfile));
          return run(files.shift());
        });
      })(files.shift());
      clean = function() {
        return exists(tmpfile, function(exists) {
          if (!exists) {
            return callback(result, error);
          }
          return fs.unlink(tmpfile, function(err) {
            return callback(result, error);
          });
        });
      };
      return this;
    };

    ImageOptimzer.prototype.optimizePNG = function(files, callback) {
      var args, error, onExit, options, optipng, result;
      error = null;
      result = '';
      options = [];
      args = options.concat(files);
      optipng = spawn(this._PNGBin, args);
      optipng.stderr.on('data', function(buffer) {
        return result += buffer.toString();
      });
      onExit = function(code) {
        return callback(error);
      };
      optipng.on('close', onExit);
      return null;
    };

    return ImageOptimzer;

  })();

}).call(this);
